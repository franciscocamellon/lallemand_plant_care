# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StatisticsService
                                 A QGIS plugin
 Lallemand Plant Care
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-09-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by ETG
        email                : etg@email.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import pandas as pd
import numpy as np

from qgis.core import (
    QgsProject,
    QgsField,
    QgsFields,
    QgsVectorLayer,
    QgsRasterLayer,
    QgsFeature,
    QgsGeometry,
    QgsPointXY,
    QgsLayerTreeGroup,
    QgsLayerTreeLayer,
    QgsCoordinateTransform,
    QgsVectorFileWriter,
    QgsCoordinateTransformContext,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsExpression
)
from qgis.PyQt.QtWidgets import QMessageBox, QFileDialog
from qgis.PyQt.Qt import QVariant

from .plot_service import PlotterService
from ...gui.settings.options_settings_dlg import OptionsSettingsPage
from .message_service import MessageService
from .system_service import SystemService
from ..constants import VALIDATION_FIELDS, GAIN_SURFACE_DATA, STATISTICS_INTERVALS, STATISTICS_INTERVAL
from ..tools.algorithm_runner import AlgorithmRunner


class StatisticsService:

    def __init__(self):
        self.settings = OptionsSettingsPage()
        self.krigingSettings = self.settings.getKrigingSettings()
        self.surfaceGainData = GAIN_SURFACE_DATA
        self.statisticsInterval = STATISTICS_INTERVAL

    def runStatistics(self, layer):

        # Extract the data into a list
        T1 = [feature['yield'] for feature in layer.getFeatures()]

        # Area calculation
        print(self.krigingSettings[1])
        area = (self.krigingSettings[1][0]) * self.krigingSettings[1][1]
        sq_area = [area for value in T1]

        # Create DataFrame with 'yield' and 'area'
        df = pd.DataFrame({'yield': T1, 'area': sq_area})

        # Define conditions for categorizing the data
        conditions = [
            df['yield'] < 0,
            (df['yield'] >= 0) & (df['yield'] < 0.5),
            (df['yield'] >= 0.5) & (df['yield'] < 1),
            df['yield'] >= 1
        ]

        # Define the choices for the intervals
        choices = ['yield<0', '0<=yield<0.5', '0.5<=yield<1', 'yield>=1']

        # Apply the conditions and choices to create 'interval' column
        df['interval'] = np.select(conditions, choices, default='other')

        # Calculate the total area
        self.surfaceGainData['TOTAL_AREA'] = df['area'].sum()
        self.surfaceGainData['TOTAL_YIELD_PRODUCTION'] = df['yield'].sum()

        # Initialize a dictionary to store the results
        results = {}

        # Iterate through the intervals and calculate required values
        for choice in choices:
            self.statisticsInterval['SQ_AREA'] = df[df['interval'] == choice]['area'].sum()
            self.statisticsInterval['PERC_AREA'] = (self.statisticsInterval['SQ_AREA'] / self.surfaceGainData['TOTAL_AREA']) * 100
            self.statisticsInterval['YIELD_SUM'] = df[df['interval'] == choice]['yield'].sum()
            self.statisticsInterval['YIELD_BY_PERC_AREA'] = self.statisticsInterval['YIELD_SUM'] / self.statisticsInterval['PERC_AREA'] if self.statisticsInterval['PERC_AREA'] != 0 else 0

            results[choice] = {
                'Total Area Sum': self.statisticsInterval['SQ_AREA'],
                'Area Percent': self.statisticsInterval['PERC_AREA'],
                'Yield Sum': self.statisticsInterval['YIELD_SUM'],
                'Yield per Area Percent': self.statisticsInterval['YIELD_BY_PERC_AREA']
            }
        print(results)
        # # Load the spreadsheet to be updated
        # spreadsheet_path = '/mnt/data/Tables_Statistics.xlsx'
        # spreadsheet = pd.read_excel(spreadsheet_path)
        #
        # # Corrected mapping between interval names and class names in the spreadsheet
        # interval_to_class_corrected = {
        #     'yield<0': '1 (<0)',
        #     '0<=yield<0.5': '2 (0 - 0.5)',
        #     '0.5<=yield<1': '3 (0.5 - 1.0)',
        #     'yield>=1': '4  (>1.0)'  # Corrected class name
        # }
        #
        # # Update each row with the new results
        # for interval, res in results.items():
        #     class_name = interval_to_class_corrected[interval]
        #     row_index = spreadsheet[spreadsheet.iloc[:, 2] == class_name].index[0]
        #     spreadsheet.at[row_index, 'Area (mÂ²)'] = res['Total Area Sum']
        #     spreadsheet.at[row_index, 'Area (%)'] = res['Area Percent']
        #     spreadsheet.at[row_index, 'Total (ton)'] = res['Yield Sum']
        #     spreadsheet.at[row_index, 'total/area'] = res['Yield per Area Percent']
        #
        # # Save the updated spreadsheet
        # updated_spreadsheet_path = '/mnt/data/Updated_Tables_Statistics.xlsx'
        # spreadsheet.to_excel(updated_spreadsheet_path, index=False)


