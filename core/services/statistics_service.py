# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StatisticsService
                                 A QGIS plugin
 Lallemand Plant Care
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-09-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by ETG
        email                : etg@email.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
import re
from scipy.stats import f_oneway
import pandas as pd
import numpy as np
from docx import Document

from qgis.core import (
    QgsProject,
    QgsField,
    QgsFields,
    QgsVectorLayer,
    QgsRasterLayer,
    QgsFeature,
    QgsGeometry,
    QgsPointXY,
    QgsLayerTreeGroup,
    QgsLayerTreeLayer,
    QgsCoordinateTransform,
    QgsVectorFileWriter,
    QgsCoordinateTransformContext,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsExpression
)
from qgis.PyQt.QtWidgets import QMessageBox, QFileDialog
from qgis.PyQt.Qt import QVariant

from .plot_service import PlotterService
from ...gui.settings.options_settings_dlg import OptionsSettingsPage
from .message_service import MessageService
from .system_service import SystemService
from .layer_service import LayerService
from ..constants import VALIDATION_FIELDS, GAIN_SURFACE_DATA, STATISTICS_INTERVALS, STATISTICS_INTERVAL
from ..tools.algorithm_runner import AlgorithmRunner


class StatisticsService:

    def __init__(self):
        self.settings = OptionsSettingsPage()
        self.krigingSettings = self.settings.getKrigingSettings()
        self.surfaceGainData = GAIN_SURFACE_DATA
        self.statisticsInterval = STATISTICS_INTERVAL
        self.layerService = LayerService()
        self.messageService = MessageService()

    @staticmethod
    def layerToDataFrame(layer, field):
        listOfValues = [feature[field] for feature in layer.getFeatures()]
        return pd.DataFrame({field: listOfValues})

    def calculateAnovaTest(self, field, firstLayer, secondLayer):
        firstDataFrame = self.layerToDataFrame(firstLayer, field)
        secondDataFrame = self.layerToDataFrame(secondLayer, field)
        fValue, pValue = f_oneway(firstDataFrame, secondDataFrame)
        return fValue.item(), pValue.item()

    def calculateMean(self, layer, field):
        dataFrame = self.layerToDataFrame(layer, field)
        return dataFrame.mean().item()

    def calculateStdDev(self, layer, field):
        dataFrame = self.layerToDataFrame(layer, field)
        return dataFrame.std().item()

    def calculateMode(self, layer, field):
        dataFrame = self.layerToDataFrame(layer, field)
        modeResult = dataFrame[field].mode()

        if not modeResult.empty:
            return modeResult.iloc[0]
        else:
            return None

    def calculateSum(self, layer, field):
        dataFrame = self.layerToDataFrame(layer, field)
        return dataFrame.sum().item()

    def calculateMedian(self, layer, field):
        dataFrame = self.layerToDataFrame(layer, field)
        return dataFrame.median().item()

    def getGainStatistics(self, layer, field):
        return [self.calculateSum(layer, field),
                self.calculateMean(layer, field),
                self.calculateMode(layer, field),
                self.calculateMedian(layer, field),
                self.calculateStdDev(layer, field)]

    def getAnovaStatistics(self, field, firstLayer, secondLayer):
        mean = [self.calculateMean(firstLayer, field),
                self.calculateMean(secondLayer, field)]
        stdDev = [self.calculateStdDev(firstLayer, field),
                  self.calculateStdDev(secondLayer, field)]
        return mean, stdDev

    def runStatistics(self, layer):
        # Extract the data into a list
        valuesList = [feature['yield'] for feature in layer.getFeatures()]

        # Area calculation
        area = (self.krigingSettings[1][0]) * self.krigingSettings[1][1]
        sq_area = [area for value in valuesList]

        # Create DataFrame with 'yield' and 'area'
        df = pd.DataFrame({'yield': valuesList, 'area': sq_area})

        # Define conditions for categorizing the data
        conditions = [
            df['yield'] < 0,
            (df['yield'] >= 0) & (df['yield'] < 0.5),
            (df['yield'] >= 0.5) & (df['yield'] < 1),
            df['yield'] >= 1
        ]

        # Define the choices for the intervals
        choices = ['yield<0', '0<=yield<0.5', '0.5<=yield<1', 'yield>=1']

        # Apply the conditions and choices to create 'interval' column
        df['interval'] = np.select(conditions, choices, default='other')

        # Calculate the total area
        self.surfaceGainData['TOTAL_AREA'] = df['area'].sum()
        self.surfaceGainData['TOTAL_YIELD_PRODUCTION'] = df['yield'].sum()

        # Initialize a dictionary to store the results
        results = {}

        # Iterate through the intervals and calculate required values
        for choice in choices:
            self.statisticsInterval['SQ_AREA'] = df[df['interval'] == choice]['area'].sum()
            self.statisticsInterval['PERC_AREA'] = (self.statisticsInterval['SQ_AREA'] / self.surfaceGainData['TOTAL_AREA']) * 100
            self.statisticsInterval['YIELD_SUM'] = df[df['interval'] == choice]['yield'].sum()
            self.statisticsInterval['YIELD_BY_PERC_AREA'] = self.statisticsInterval['YIELD_SUM'] / self.statisticsInterval['PERC_AREA'] if self.statisticsInterval['PERC_AREA'] != 0 else 0

            results[choice] = {
                'Total Area Sum': self.statisticsInterval['SQ_AREA'],
                'Area Percent': self.statisticsInterval['PERC_AREA'],
                'Yield Sum': self.statisticsInterval['YIELD_SUM'],
                'Yield per Area Percent': self.statisticsInterval['YIELD_BY_PERC_AREA']
            }
            # 'intervalStrings':'',
            # 'interval_area_percentage'
            # 'interval_total'
        print(results)
        return results
