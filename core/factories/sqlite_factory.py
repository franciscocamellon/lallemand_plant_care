# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SqliteFactory
                                 A QGIS plugin
 Lallemand Plant Care
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-10-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by CamellOnCase
        email                : camelloncase@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os

import sqlite3
import logging
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT

from ...gui.settings.options_settings_dlg import OptionsSettingsPage


class SqliteFactory:
    def __init__(self):
        super(SqliteFactory, self).__init__()
        self._initializeLogging()
        # self.connection = self.openConnection()

    @staticmethod
    def _initializeLogging():
        logging.basicConfig(filename=os.path.join(os.path.dirname(__file__), 'sqlite_log.log'), level=logging.ERROR)

    def openConnection(self):
        sqliteDatabase = OptionsSettingsPage().getSqliteSettings()
        with sqlite3.connect(
            database=sqliteDatabase
        ) as connection:
            connection.isolation_level = 'DEFERRED'
            connection.autocommit = sqlite3.LEGACY_TRANSACTION_CONTROL
        return connection

    def fetchDataToCombobox(self, combobox, query, displayColumns, idColumn, concatSeparator=' '):
        try:
            combobox.clear()
            result = self.getSqlExecutor(query)

            for row in result:
                displayValue = concatSeparator.join([str(row[column]) for column in displayColumns])
                combobox.addItem(displayValue, row[idColumn])

            return True, combobox

        except Exception as e:
            errorMessage = f"Error executing SQL query: {str(e)}"
            return False, errorMessage

    def fetchOne(self, baseSql, objectId):
        objectSql = baseSql.format(objectId)
        return self.getSqlExecutor(objectSql)

    def getSqlExecutor(self, sql):
        try:
            connection = self.openConnection()
            with connection.cursor() as curs:
                curs.execute(sql)
                result = curs.fetchall()
            return result

        except sqlite3.Error as e:
            error_message = f"Error executing SQL: {e}"
            logging.error(error_message)
            return error_message

    def postSqlExecutor(self, sql, data=None):
        try:
            connection = self.openConnection()
            with connection.cursor() as curs:
                if data:
                    curs.execute(sql, data)
                else:
                    curs.execute(sql)
            return True

        except sqlite3.Error as e:
            error_message = f"Error executing SQL: {e}"
            logging.error(error_message)
            return False, error_message

    @staticmethod
    def close_connection(connection):
        connection.close()
