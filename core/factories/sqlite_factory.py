# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SqliteFactory
                                 A QGIS plugin
 Lallemand Plant Care
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-10-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by CamellOnCase
        email                : camelloncase@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os

import sqlite3
import logging
from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT

from ..services.layer_service import LayerService
from ...gui.settings.options_settings_dlg import OptionsSettingsPage


class SqliteFactory:
    def __init__(self):
        super(SqliteFactory, self).__init__()
        self.layerService = LayerService()
        self._initializeLogging()
        # self.connection = self.openConnection()

    @staticmethod
    def _initializeLogging():
        logging.basicConfig(filename=os.path.join(os.path.dirname(__file__), 'sqlite_log.log'), level=logging.ERROR)

    def openConnection(self):
        sqliteDatabase = self.layerService.getSqlitePath()
        # sqliteDatabase = OptionsSettingsPage().getSqliteSettings()
        return sqlite3.connect(database=sqliteDatabase)

    def fetchDataToCombobox(self, combobox, query, displayColumns, idColumn, concatSeparator=' '):
        try:
            combobox.clear()
            result = self.getSqlExecutor(query, dictionary=True)

            for row in result:
                displayValue = concatSeparator.join([str(row[column]) for column in displayColumns])
                combobox.addItem(displayValue, row[idColumn])

            return True, combobox

        except Exception as e:
            errorMessage = f"Error executing SQL query: {str(e)}"
            return False, errorMessage

    def fetchOne(self, baseSql, objectId, dictionary=False):
        objectSql = baseSql.format(objectId)
        return self.getSqlExecutor(objectSql, dictionary=dictionary)

    def getSqlExecutor(self, sql, dictionary=False):
        try:
            connection = self.openConnection()
            if dictionary:
                connection.row_factory = sqlite3.Row
            cursor = connection.cursor()
            result = cursor.execute(sql)

            return result.fetchall()

        except sqlite3.Error as e:
            error_message = f"Error executing SQL: {e}"
            logging.error(error_message)
            return error_message

    def postSqlExecutor(self, sql, data=None):
        try:
            connection = self.openConnection()
            curs = connection.cursor()
            if data:
                curs.execute(sql, data)
                connection.commit()
            else:
                curs.execute(sql)
                connection.commit()
            return True

        except sqlite3.Error as e:
            error_message = f"Error executing SQL: {e}"
            logging.error(error_message)
            return False, error_message

    @staticmethod
    def close_connection(connection):
        connection.close()
